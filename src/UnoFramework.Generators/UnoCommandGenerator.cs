// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using UnoFramework.Generators.Models;

namespace UnoFramework.Generators;

/// <summary>
/// A source generator that generates command properties for methods annotated with <see cref="UnoCommandAttribute"/>.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class UnoCommandGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("UnoCommandAttribute.g.cs", SourceText.From("""
                // <auto-generated/>
                #nullable enable

                namespace UnoFramework.Generators;

                /// <summary>
                /// An attribute that can be used to automatically generate command implementations for annotated methods.
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                internal sealed class UnoCommandAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Gets or sets a value indicating whether a cancel command should also be generated for an asynchronous command.
                    /// </summary>
                    public bool IncludeCancelCommand { get; init; }

                    /// <summary>
                    /// Gets or sets the busy mode for the command. When set to Local or Global, the command execution
                    /// will be wrapped with BeginBusy/BeginGlobalBusy.
                    /// </summary>
                    public global::UnoFramework.Contracts.Busy.BusyMode Busy { get; init; } = global::UnoFramework.Contracts.Busy.BusyMode.None;

                    /// <summary>
                    /// Gets or sets the optional message to display during busy state.
                    /// </summary>
                    public string? BusyMessage { get; init; }
                }
                """, Encoding.UTF8));
        });

        // Find all methods with the UnoCommand attribute using syntax-based detection
        IncrementalValuesProvider<CommandInfo?> commandInfos = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsUnoCommandMethod(node),
                transform: static (context, cancellationToken) => GetCommandInfoFromSyntax(context, cancellationToken))
            .Where(static info => info is not null);

        // Generate source for each command
        context.RegisterSourceOutput(commandInfos, static (context, commandInfo) =>
        {
            if (commandInfo is null)
                return;

            string source = GenerateCommandSource(commandInfo);
            context.AddSource($"{commandInfo.ContainingTypeName}.{commandInfo.CommandName}.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    /// <summary>
    /// Checks if a syntax node is a method with the UnoCommand attribute.
    /// </summary>
    private static bool IsUnoCommandMethod(SyntaxNode node)
    {
        if (node is not MethodDeclarationSyntax method)
            return false;

        foreach (var attributeList in method.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                string name = attribute.Name.ToString();
                if (name == "UnoCommand" || name == "UnoCommandAttribute")
                    return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Extracts command information from a method with the UnoCommand attribute using syntax context.
    /// </summary>
    private static CommandInfo? GetCommandInfoFromSyntax(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not MethodDeclarationSyntax methodSyntax)
            return null;

        IMethodSymbol? methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodSyntax, cancellationToken) as IMethodSymbol;
        if (methodSymbol is null)
            return null;

        INamedTypeSymbol? containingType = methodSymbol.ContainingType;
        if (containingType is null)
            return null;

        // Find the UnoCommand attribute
        AttributeData? attributeData = null;
        foreach (var attr in methodSymbol.GetAttributes())
        {
            string? attrName = attr.AttributeClass?.Name;
            if (attrName == "UnoCommandAttribute" || attrName == "UnoCommand")
            {
                attributeData = attr;
                break;
            }
        }

        if (attributeData is null)
            return null;

        // Extract attribute properties
        bool includeCancelCommand = false;
        int busy = 0; // 0 = None, 1 = Local, 2 = Global
        string? busyMessage = null;

        foreach (KeyValuePair<string, TypedConstant> namedArg in attributeData.NamedArguments)
        {
            switch (namedArg.Key)
            {
                case "IncludeCancelCommand" when namedArg.Value.Value is bool boolValue:
                    includeCancelCommand = boolValue;
                    break;
                case "Busy" when namedArg.Value.Value is int intValue:
                    busy = intValue;
                    break;
                case "BusyMessage" when namedArg.Value.Value is string stringValue:
                    busyMessage = stringValue;
                    break;
            }
        }

        // Determine if method is async
        bool isAsync = methodSymbol.ReturnType.Name == "Task" ||
                       methodSymbol.ReturnType.Name == "ValueTask" ||
                       (methodSymbol.ReturnType is INamedTypeSymbol returnType &&
                        (returnType.ConstructedFrom.Name == "Task" || returnType.ConstructedFrom.Name == "ValueTask"));

        // Check if method supports cancellation (has CancellationToken parameter)
        bool supportsCancellation = methodSymbol.Parameters.Any(p =>
            p.Type.Name == "CancellationToken" ||
            p.Type.ToDisplayString() == "System.Threading.CancellationToken");

        // Get parameter type (excluding CancellationToken)
        string? parameterType = null;
        foreach (IParameterSymbol param in methodSymbol.Parameters)
        {
            if (param.Type.Name != "CancellationToken" &&
                param.Type.ToDisplayString() != "System.Threading.CancellationToken")
            {
                parameterType = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                break;
            }
        }

        // Generate names
        string methodName = methodSymbol.Name;
        string commandName = GetCommandName(methodName);
        string fieldName = $"_{char.ToLowerInvariant(commandName[0])}{commandName.Substring(1)}";

        string? cancelCommandName = null;
        string? cancelCommandFieldName = null;
        if (includeCancelCommand && isAsync && supportsCancellation)
        {
            cancelCommandName = $"{commandName.Replace("Command", "")}CancelCommand";
            if (cancelCommandName == "CancelCommand")
                cancelCommandName = $"{commandName}Cancel";
            cancelCommandFieldName = $"_{char.ToLowerInvariant(cancelCommandName[0])}{cancelCommandName.Substring(1)}";
        }

        // Get containing type info
        string containingTypeName = containingType.Name;
        string containingTypeNamespace = containingType.ContainingNamespace?.ToDisplayString() ?? "";
        string containingTypeAccessibility = containingType.DeclaredAccessibility.ToString().ToLowerInvariant();

        return new CommandInfo(
            methodName,
            commandName,
            fieldName,
            isAsync,
            supportsCancellation,
            includeCancelCommand && isAsync && supportsCancellation,
            cancelCommandName,
            cancelCommandFieldName,
            parameterType,
            containingTypeName,
            containingTypeNamespace,
            containingTypeAccessibility,
            busy,
            busyMessage);
    }

    /// <summary>
    /// Gets the command property name from a method name.
    /// </summary>
    private static string GetCommandName(string methodName)
    {
        // Remove common async suffixes
        if (methodName.EndsWith("Async"))
            methodName = methodName.Substring(0, methodName.Length - 5);

        // Add "Command" suffix if not present
        if (!methodName.EndsWith("Command"))
            methodName += "Command";

        return methodName;
    }

    /// <summary>
    /// Generates the source code for a command.
    /// </summary>
    private static string GenerateCommandSource(CommandInfo info)
    {
        StringBuilder sb = new();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.ContainingTypeNamespace))
        {
            sb.AppendLine($"namespace {info.ContainingTypeNamespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {info.ContainingTypeName}");
        sb.AppendLine("{");

        // Determine if we need a wrapper method for busy handling
        // Busy: 0 = None, 1 = Local, 2 = Global
        bool needsBusyWrapper = info.Busy != 0 && info.IsAsync;
        string targetMethodName = needsBusyWrapper ? $"__{info.MethodName}__BusyWrapper" : info.MethodName;

        // Generate command type
        string commandType;
        string commandCreation;

        if (info.IsAsync)
        {
            if (info.ParameterType is not null)
            {
                commandType = $"global::CommunityToolkit.Mvvm.Input.IAsyncRelayCommand<{info.ParameterType}>";
                commandCreation = $"new global::CommunityToolkit.Mvvm.Input.AsyncRelayCommand<{info.ParameterType}>({targetMethodName})";
            }
            else
            {
                commandType = "global::CommunityToolkit.Mvvm.Input.IAsyncRelayCommand";
                commandCreation = $"new global::CommunityToolkit.Mvvm.Input.AsyncRelayCommand({targetMethodName})";
            }
        }
        else
        {
            if (info.ParameterType is not null)
            {
                commandType = $"global::CommunityToolkit.Mvvm.Input.IRelayCommand<{info.ParameterType}>";
                commandCreation = $"new global::CommunityToolkit.Mvvm.Input.RelayCommand<{info.ParameterType}>({info.MethodName})";
            }
            else
            {
                commandType = "global::CommunityToolkit.Mvvm.Input.IRelayCommand";
                commandCreation = $"new global::CommunityToolkit.Mvvm.Input.RelayCommand({info.MethodName})";
            }
        }

        // Generate busy wrapper method if needed
        // Busy: 1 = Local, 2 = Global
        if (needsBusyWrapper)
        {
            string busyMethodName = info.Busy == 2 ? "BeginGlobalBusy" : "BeginBusy";
            string busyMessageArg = info.BusyMessage is not null ? $"\"{info.BusyMessage}\"" : "null";
            string parameterDecl = info.ParameterType is not null ? $"{info.ParameterType} __param__" : "";
            string parameterPass = info.ParameterType is not null ? "__param__" : "";

            sb.AppendLine($"    private async global::System.Threading.Tasks.Task {targetMethodName}({parameterDecl})");
            sb.AppendLine("    {");
            sb.AppendLine($"        using ({busyMethodName}({busyMessageArg}))");
            sb.AppendLine("        {");
            if (info.ParameterType is not null)
            {
                sb.AppendLine($"            await {info.MethodName}({parameterPass});");
            }
            else
            {
                sb.AppendLine($"            await {info.MethodName}();");
            }
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Generate field
        sb.AppendLine($"    private {commandType}? {info.FieldName};");
        sb.AppendLine();

        // Generate property
        sb.AppendLine($"    /// <summary>Gets the command that invokes <see cref=\"{info.MethodName}\"/>.</summary>");
        sb.AppendLine($"    public {commandType} {info.CommandName} => {info.FieldName} ??= {commandCreation};");

        // Generate cancel command if needed
        if (info.IncludeCancelCommand && info.CancelCommandName is not null && info.CancelCommandFieldName is not null)
        {
            sb.AppendLine();
            sb.AppendLine($"    private global::System.Windows.Input.ICommand? {info.CancelCommandFieldName};");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>Gets the cancel command for <see cref=\"{info.CommandName}\"/>.</summary>");
            sb.AppendLine($"    public global::System.Windows.Input.ICommand {info.CancelCommandName} => {info.CancelCommandFieldName} ??= global::CommunityToolkit.Mvvm.Input.IAsyncRelayCommandExtensions.CreateCancelCommand({info.CommandName});");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
}
